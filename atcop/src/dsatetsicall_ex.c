/*====*====*====*====*====*====*====*====*====*====*====*====*====*====*====*

                D A T A   S E R V I C E S

                U M T S

                C A L L   C O N T R O L
                                
                A T   C O M M A N D   P R O C E S S I N G

GENERAL DESCRIPTION
  This module executes AT commands. It executes UMTS specific call control 
  AT commands.

  
EXTERNALIZED FUNCTIONS
  dsat_send_cr_result
    Sends intermediate service reporting result code to TE or PS protocol
    stack based on response routing provided by response router.
    

EXTERNALIZED FUNCTIONS INTERNAL TO DSAT UNIT
  dsatetsicall_init_call
    This function intializes ETSI call handling.

  dsatetsicall_exec_cdip_cmd
    This function takes the result from the command line parser and executes 
    it. It executes +CDIP command, which enables/disables the display of 
    called line identification.
  
  dsatetsicall_exec_ctfr_cmd
    This function takes the result from the command line parser and executes 
    it. It executes +CTFR command, which controls the call deflection (call Transfer)
    supplementary service acording to 3GPP TS 22.072 [30]
      
  dsatetsicall_set_crc_result
    Produces unformatted incoming call indication or GPRS network request
    for PDP context activation result and returns in DSM item.

  dsatetsicall_exec_cbst_cmd
    This function takes the result from the command line parser
    and executes it. It executes +CBST command.It is used to select
    bearer services to be used when data calls are originated. 

  dsatetsicall_voice_dial_cmd
    Handle atd voice dial commands.  This function is called by 
    dsatact_exec_atd_cmd when dial string has ;.

  dsatetsicall_exec_chup_cmd
    This is the command handler function for +CHUP.

  dsatetsicall_exec_ccfc_cmd
    This function takes the result from the command line parser and executes 
    it. 

  dsatetsicall_report_ccfc
    This function reports the call forwarding supplementary service status
    received from Call Manager.

  dsatetsicall_exec_clck_cmd
    This function controls the facility lock supplementary service.

  dsatetsicall_report_clck
    This function reports the facility lock supplementary service status
    received from Call Manager.

  dsatetsicall_exec_cpwd_cmd
    This function sets new passwords for facility lock supplementary service.

  dsatetsicall_exec_cusd_cmd
    This function control of Unstructured Supplementary Service Data (USSD).

  dsatetsicall_exec_ccwa_cmd
    This function controls the call waiting supplementary service. 

  dsatetsicall_exec_chld_cmd
    This function controls the call hold supplementary service. 

  dsatetsicall_update_call_state
    Maintains call state, held/active, for voice and CS data calls. 
    
  dsatetsicall_sups_cmd_cb_handler
    Handles error responses for CM Supplementary Service commands generated by
    +CHLD command

  dsatetsicall_call_event_mng_calls_conf_ex
    Handles CM_CALL_EVENT_MNG_CALLS_CONF events, keeping call state info up to 
    date.

  dsatetsicall_call_event_connect_ex
    Handles CM_CALL_EVENT_CONNECT events, keeping call state info up to 
    date.

  dsatetsicall_call_event_end_ex
    Handles CM_CALL_EVENT_END events, keeping call state info up to 
    date.

  dsatetsicall_call_event_incom
    Handles CM_CALL_EVENT_INCOM events, keeping call state info up to 
    date.

  dsatetsicall_exec_es_cmd
    This function executes +ES command, which set parameters for entering 
    or exiting synchronous access mode.

  dsatetsicall_exec_esa_cmd
    This function executes +ESA command, which set parameters for synchronous 
    access mode configuration.

  dsatetsicall_es_export
    This function export the +ES's value to other subsystem.

  dsatetsicall_esa_export
    This function export the +ESA's value to other subsystem.

  dsatetsicall_exec_crlp_cmd
    This function takes the result from the command line parser and executes 
    it. It executes +CRLP command, which processes parameters for
    non-transparnet/asynchronous circuit-switched data calls.

  dsatetsicall_crlp_response_fmt
    This function generates the response for the +CRLP read & test
    commands.  The &V command respose is handled as well.  Data is
    extracted from data structure and formatted according to
    parameter flag.

  dsatetsicall_init_crlp_export
    This function intializes the +CRLP multidimensional value list.

  dsatetsicall_exec_caoc_cmd
    This function takes the result from the command line parser and
    executes it. It executes +CAOC command, which enables/disables
    unsolitited result codes for advice of charge supplementary service.

  dsatetsicall_caoc_timer_expired_handler 
    This function is the handler function for the +CAOC command
    reporting timer expired event.

  dsatetsicall_exec_cacm_cmd
    This function takes the result from the command line parser and
    executes it. It executes +CACM command, which reports the
    accumulated call meteter from the SIM/USIM.
    
  dsatetsicall_exec_camm_cmd
    This function takes the result from the command line parser and
    executes it. It executes +CAMM command, which reports or resets the 
    accumulated call meter maximum from the SIM/USIM.

  dsatetsicall_aoc_verify_pin_handler
    This function is the handler function for the +CACM/+CAMM commands
    PIN2 verification.

  dsatetsicall_exec_cpuc_cmd
    This function takes the result from the command line parser and
    executes it. It executes +CPUC command, which reports or sets the 
    Price per Unit and Currency table from the SIM/USIM.

  dsatetsicall_exec_cops_cmd
    This function takes the result from the command line parser and executes 
    it. It executes +COPS command, which list available networks and sets
    automatic/manual registration.

  dsatetsicall_cops_abort_cmd_handler
  dsatetsicall_cops_abort_event_handler
    This function handles an abort command to terminate asynchronous
    processing for +COPS registration operation.
    
  dsatetsicall_cops_asynch_handler
    This function manages the asynchronous processing of the +COPS
    command. 

  dsatetsicall_exec_ceer_cmd
    This function takes the result from the command line parser and
    executes it. It executes +CEER command, which report the reason
    for the last call failure to setup or release.

  dsatetsicall_exec_cqi_cmd
    This function takes the result from the command line parser and
    executes it. It executes +CQI command, which report the GW Channel 
    Quality Indicator.
    
   Copyright (c) 2001 - 2020 by Qualcomm Technologies Incorporated.
   All Rights Reserved.
   Qualcomm Confidential and Proprietary.
*====*====*====*====*====*====*====*====*====*====*====*====*====*====*====*/


/*===========================================================================

                        EDIT HISTORY FOR MODULE

  This section contains comments describing changes made to the module.
  Notice that changes are listed in reverse chronological order.

   $Header: //commercial/MPSS.HI.1.0.c8/Main/modem_proc/datamodem_r/interface/atcop/src/dsatetsicall_ex.c#5 $ $DateTime: 2020/03/23 01:20:28 $ $Author: kiras $

when       who     what, where, why
--------   ---     ----------------------------------------------------------
10/31/19   ks      Added support for tac_5g.
08/22/19   ks      Fixed issue with CGREG URC incorrect after service resume request
06/29/18   skc     Added support to save incoming call to phonebook.
03/27/18   skc     Fixed issue with CREG and CGREG URCs.
12/22/17   skc     Added enhancement on supplementary service for IP Call sub-phase 2.
12/15/17   skc     Added enhancement on supplementary service for IP Call.
09/13/17   skc     Added support for VT Call.
08/01/17   skc     Made changes to handle CHLD and CLCC for SRVCCed MPTY Call.
12/08/16   skc     Added enhancement on CHLD and CLCC for VoLTE MPTY Call.
11/30/16   skc     Added support for AT+VTS before connect event.
11/02/16   skc     Fixed Cell info update issue if sys mode mismatched.
09/21/16   skc     Reduced print for excessinve F3s.
04/30/15   sc      Fixed +CHLD command issue to use requesting client id
                   instead of call client id. 
04/16/15   sc      Fixed issue in event handling to use subs_id provided in 
                   event info.
06/27/14   tk/sc   Initial revision (created file for Dynamic ATCoP).
07/08/14   sc      Fixed SGLTE+G issue on SUB2.

===========================================================================*/


/*===========================================================================

                     INCLUDE FILES FOR MODULE

===========================================================================*/
#include "datamodem_variation.h"
#include "comdef.h"
#include "customer.h"

#include <stringl/stringl.h>


/* This file should be included only in GSM or WCDMA mode */
#ifdef FEATURE_DSAT_ETSI_MODE

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include "rex.h"
#include "amssassert.h"
#include "err.h"
#include "msg.h"
#include "cmutil.h"
#if defined(T_WINNT) || defined(T_UNIX)
#ifdef TEST_FRAMEWORK
#error code not present
#endif /* TEST_FRAMEWORK */
#endif /* WINNT || UNIX */



#include "dsati.h"
#include "dsatact.h"
#include "dsatctab.h"
#include "dsatdl.h"
#include "dsatetsicall.h"
#include "dsatetsictab.h"
#include "dsatetsime.h"
#include "dsatetsicmif.h"
#include "dsatcmif.h"
#include "dsatparm.h"
#include "dsatvoice.h"
#include "ds_cap.h" /* ITC_SPEECH */
#include "mn_cm_exp.h"
#include "dsucsdhdlr.h"
#include "dsumtsps.h"

#ifdef FEATURE_DSAT_ETSI_DATA
#include "dsatetsipkt.h"
#endif /* FEATURE_DSAT_ETSI_DATA */

#include "ds3gsiolib.h"

#ifdef FEATURE_DATA_GCSD_FAX
  #include "dsatgsmfax.h"
#endif /* FEATURE_DATA_GCSD_FAX */


#ifdef FEATURE_DATA_WCDMA_PS
#include "dsatvend.h"
#endif /* FEATURE_DATA_WCDMA_PS */

#include "dsutil.h"
#include "sys_v.h"


#define CSSU_ENABLE 1
#define CSSU_DISABLE 0

/*===========================================================================

            PUBLIC DEFINITIONS AND DECLARATIONS FOR MODULE

  This section contains public definitions for constants, macros, types,
  variables and other items needed by this module.

===========================================================================*/
rex_timer_type dsatetsicall_aoc_timer;
rex_timer_type dsatetsicall_inband_dtmf_timer;

/*-------------------------------------------------------------------------
    External Variables:
-------------------------------------------------------------------------*/

/*===========================================================================

            LOCAL DEFINITIONS AND DECLARATIONS FOR MODULE

  This section contains local definitions for constants, macros, types,
  variables and other items needed by this module.

===========================================================================*/

#define DSATETSICALL_EX_ASSERT(expression) \
         dsatetsicall_ex_assert_wrapper(__LINE__, expression)

/*-------------------------------------------------------------------------
    Local variables:
-------------------------------------------------------------------------*/
/* CM serving system state information */
#if defined(FEATURE_DATA_GCSD) || defined(FEATURE_DATA_WCDMA_CS)
/* Enum for refernce to +CRLP elements */
enum crlp_params
{
  CRLP_IWS,
  CRLP_MWS,  
  CRLP_T1,  
  CRLP_N2,  
  CRLP_VERSION
};

/* Map RLP version to ATCOP parameter limit array element */
/* RLP v0/1 -> element 0 */
/* RLP v2   -> element 1 */
const byte rlpv_xref[] = {0, 0, 1}; 

#endif /* defined(FEATURE_DATA_GCSD) || defined(FEATURE_DATA_WCDMA_CS) */

/* +CHLD command: */
/* To keep track of supplementary service command in progress */
etsicall_cmd_type etsicall_cmd_pending[DSAT_SYS_MODEM_AS_ID_MAX];

/*-------------------------------------------------------------------------
    Prototypes for local functions:
-------------------------------------------------------------------------*/

LOCAL boolean etsicall_is_valid_cell_info
(
  const ds_at_ss_info_s_type   *event_info,        /* DS event pointer */
  sys_modem_as_id_e_type        subs_id            /*  Subs ID */
);

/*-------------------------------------------------------------------------
    Function Definitions:
-------------------------------------------------------------------------*/

/*===========================================================================

FUNCTION DSATETSICALL_EX_ASSERT_WRAPPER()

DESCRIPTION
  Wrapper function for DSATETSICALL_EX ASSERT
 
DEPENDENCIES 
  None

RETURN VALUE
  None
 
SIDE EFFECTS

===========================================================================*/
static void dsatetsicall_ex_assert_wrapper
(
  unsigned int     line_num,
  int              expression
)
{
  if ( !expression )
  {
    ERR_FATAL("DSATETSICALL_EX_FATAL at line:%d ",  
                                   line_num,0,0);  
  }
}/* dsatetsicall_ex_assert_wrapper */

/*===========================================================================

FUNCTION  DSAT_SEND_CR_RESULT

DESCRIPTION
  Sends intermediate service reporting result code to TE or PS protocol
  stack based on response routing provided by response router.

  Should be called from mode specific protocol stack at time during
  connection negotiation that speed and quality of service is determined 
  and before compression and connect result code are sent.
 
DEPENDENCIES
  None
  
RETURN VALUE
  None
  
SIDE EFFECTS
  None
===========================================================================*/
void dsat_send_cr_result
(
  dsat_cr_service_e_type service
)
{
  DSAT_DL_CHECK_SYMBOL_ADDR(dsatdl_vtable.dsatetsicall_send_cr_result_fp);

  dsatdl_vtable.dsatetsicall_send_cr_result_fp(service);

  return;
} /* dsat_send_cr_result( ) */

/*===========================================================================

FUNCTION  DSAT_SEND_CR_RESULT_EX

DESCRIPTION
  Sends intermediate service reporting result code to TE or PS protocol
  stack based on response routing provided by response router.

  Should be called from mode specific protocol stack at time during
  connection negotiation that speed and quality of service is determined 
  and before compression and connect result code are sent.
 
DEPENDENCIES
  None
  
RETURN VALUE
  None
  
SIDE EFFECTS
  None
===========================================================================*/
void dsat_send_cr_result_ex
(
  dsat_cr_service_e_type service,
  ds3g_siolib_port_e_type port 
)
{
  DSAT_DL_CHECK_SYMBOL_ADDR(dsatdl_vtable.dsatetsicall_send_cr_result_ex_fp);

  dsatdl_vtable.dsatetsicall_send_cr_result_ex_fp(service, port);

  return;
} /* dsat_send_cr_result_ex( ) */


/*===========================================================================

FUNCTION  DSATETSICALL_INIT_CALL

DESCRIPTION
  This function intializes ETSI call handling.

DEPENDENCIES
  None
  
RETURN VALUE
  None
  
SIDE EFFECTS
  None
===========================================================================*/
void dsatetsicall_init_call ( void )
{
  sys_modem_as_id_e_type subs_id;

#if defined(FEATURE_DATA_GCSD) || defined(FEATURE_DATA_WCDMA_CS)
  dsat_num_item_type* temp_dsat_cbst_export_val;
  /*-------------------------------------------------------------------------
    Initialize the exported CBST parameters
    -------------------------------------------------------------------------*/
  temp_dsat_cbst_export_val = dsat_get_cbst_export_val(0);
  (void)dsatutil_atoi(temp_dsat_cbst_export_val,
                  &dsat_cbst_speed_valstr[dsat_cbst_list[0].default_v][0],10);
  temp_dsat_cbst_export_val = dsat_get_cbst_export_val(1);
  (void)dsatutil_atoi(temp_dsat_cbst_export_val,
                  &dsat_cbst_name_valstr[dsat_cbst_list[1].default_v][0],10);
  temp_dsat_cbst_export_val = dsat_get_cbst_export_val(2);
  (void)dsatutil_atoi(temp_dsat_cbst_export_val,
                  &dsat_cbst_ce_valstr[dsat_cbst_list[2].default_v][0],10);

  /*------------------------------------------------------------------------
    Initialize the exported CSD RLP parameters
    -------------------------------------------------------------------------*/
  dsatetsicall_init_rlp_export( );
#endif /* defined(FEATURE_DATA_GCSD) || defined(FEATURE_DATA_WCDMA_CS) */

#ifdef FEATURE_DATA_GCSD_FAX 
  /*------------------------------------------------------------------------
    Initialize the exported CSD Fax Protocol Stack parameters
  -------------------------------------------------------------------------*/
dsatgsmfax_set_stack_params();
#endif /* FEATURE_DATA_GCSD_FAX */
  
#ifdef FEATURE_WCDMA
  /*-------------------------------------------------------------------------
    Initialize the exported +ES and +ESA parameters
  -------------------------------------------------------------------------*/
  dsatetsicall_es_export();
  dsatetsicall_esa_export();
#endif /* FEATURE_WCDMA */

  for (subs_id = SYS_MODEM_AS_ID_1; subs_id < DSAT_SYS_MODEM_AS_ID_MAX; subs_id++)
  {
    etsicall_cmd_pending[subs_id] = CMD_NONE;
  }

  return;
} /* dsatetsicall_init_call() */

/*===========================================================================

FUNCTION DSATETSICALL_RESET_LAST_REPORTED_CREG

DESCRIPTION
  This function reset last reported creg parameter

DEPENDENCIES
  None
  
RETURN VALUE
  None

SIDE EFFECTS
  None
  
===========================================================================*/
void dsatetsicall_reset_last_reported_creg(dsatcmif_servs_state_ms_info  *ph_ss_ms_val)
{

  ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.net_domain[0] =
  ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.net_domain[1] = DSAT_REG_REGISTERED_MAX;
  ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.act = DSAT_COPS_ACT_MAX;
  ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.cell_id = 0xFFFFFFFF;
  ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.lte_tac = 0XFFFF;
  ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.lte_rac_or_mme_code = 0XFF;
  ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.psc = 0XFFFF;
  ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.plmn_lac = 0XFFFF;
  ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.reg_rej_state = DSAT_CREG_STAT_CNG_UNLCK;
  ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.cops_pending_report_creg = REPORT_NONE;
  ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.pending_cell_info_update = FALSE;
}

/*===========================================================================

FUNCTION DSATETSICALL_SET_NET_REG

DESCRIPTION
  This function set last reported domain.

DEPENDENCIES
  None
  
RETURN VALUE
  None

SIDE EFFECTS
  None
  
===========================================================================*/

void dsatetsicall_set_net_reg
(
  net_reg_domain_e_type  domain ,
  net_reg_status_e_type  value,
  sys_modem_as_id_e_type subs_id
)
{

#define CHECK_STATE_CHANGE(prev,latest,flag)\
        if(prev != latest)\
          report_creg |= flag;\
          
#define PREV_CS_DOMAIN  ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.net_domain[DSAT_NET_REG_DOMAIN_CS]
#define PREV_PS_DOMAIN  ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.net_domain[DSAT_NET_REG_DOMAIN_PS]

  dsat_creg_report_e_type      report_creg = REPORT_NONE;
  dsatcmif_servs_state_ms_info  *ph_ss_ms_val = NULL;
  
   ph_ss_ms_val = dsat_get_base_addr_per_subs(DSAT_SS_PH_MS_VALS, subs_id, TRUE);
   if (NULL == ph_ss_ms_val)
   {
     return;
   }

   /*Report Creg if change*/
   if(domain == DSAT_NET_REG_DOMAIN_CS)
   {
     CHECK_STATE_CHANGE(PREV_CS_DOMAIN,value,REPORT_CREG)
   }
   else
   {
     CHECK_STATE_CHANGE(PREV_PS_DOMAIN,value,REPORT_CGREG)
   }
   ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.net_domain[domain] = value;
  
  if (DSAT_DL_VALIDATE_SYMBOL_ADDR(dsatdl_vtable.dsatetsicall_report_creg_result_fp))
  {
    dsatdl_vtable.dsatetsicall_report_creg_result_fp(DSAT_STACK_MAIN, subs_id, report_creg);
  }

  return;
}/* dsatetsicall_set_net_reg */

/*===========================================================================

FUNCTION DSATETSICALL_CREG_GET_NET_REG_STATUS

DESCRIPTION
  This function return CREG network registration status based on COPS 
  and CFUN value.

DEPENDENCIES
  None
  
RETURN VALUE
  NET REG STATUS

SIDE EFFECTS
  None
  
===========================================================================*/
net_reg_status_e_type  dsatetsicall_creg_get_net_reg_status
(
  const ds_at_cm_ss_event_type * event_ptr,        /* DS event pointer */
  dsat_stack_id_e_type           stack_id,
  sys_modem_as_id_e_type         subs_id
)
{
  net_reg_status_e_type        net_val = DSAT_NET_REG_NONE;
  sys_oprt_mode_e_type         oprt_mode = dsatcmif_get_oprt_mode();

  if ( ( NULL == event_ptr ) ||
       ( FALSE == IS_VALID_STACK_ID(stack_id) ) ||
       ( FALSE == IS_VALID_SUBS_ID(subs_id) ) )
  {
    DS_AT_MSG3_ERROR("Invalid Arg: event_ptr = %p, stack_id = %d, subs_id = %d",
                     event_ptr, stack_id, subs_id);
    return DSAT_NET_REG_NONE;
  }

  /*Setting Net registration status based on CFUN and COPS values*/

  if(DSAT_COPS_MODE_AUTO ==(dsat_num_item_type)dsatutil_get_val(DSATETSI_EXT_ACT_COPS_ETSI_IDX,subs_id,0,MIX_NUM_TYPE))
  {
  
    net_val = DSAT_NET_REG_SEARCHING;
    
  }else if((DSAT_COPS_MODE_MANUAL ==(dsat_num_item_type)dsatutil_get_val(
       DSATETSI_EXT_ACT_COPS_ETSI_IDX,subs_id,0,MIX_NUM_TYPE) ))
  {
    net_val = DSAT_NET_REG_NONE;
    
  }
  if( (event_ptr->event_info[stack_id].srv_status == SYS_SRV_STATUS_NO_SRV)||
            (event_ptr->event_info[stack_id].srv_status == SYS_SRV_STATUS_PWR_SAVE))
  {
    dsatcmif_servs_state_ss_info  *ph_ss_val = NULL;
    ph_ss_val = dsat_get_base_addr(DSAT_SS_PH_SS_VALS, TRUE);
    if (NULL == ph_ss_val)
    {
      return DSAT_NET_REG_NONE;
    }
    if( TRUE == ph_ss_val->cm_ph_deep_sleep )
    {
      net_val =  DSAT_NET_REG_NONE;
    }        
  }
  if ( ( SYS_OPRT_MODE_LPM == oprt_mode) ||
       ( SYS_OPRT_MODE_FTM == oprt_mode) ||
       ( SYS_OPRT_MODE_OFFLINE      == oprt_mode) ||
       ( SYS_OPRT_MODE_OFFLINE_AMPS == oprt_mode) ||
       ( SYS_OPRT_MODE_OFFLINE_CDMA == oprt_mode) )
  {
      net_val = DSAT_NET_REG_NONE;
  }
   /*If cops in Deregistration state then creg must be No service */
  if ( DSAT_COPS_MODE_DEREG == (dsat_num_item_type)dsatutil_get_val(
                       DSATETSI_EXT_ACT_COPS_ETSI_IDX,subs_id,0,MIX_NUM_TYPE))
  {
    net_val = DSAT_NET_REG_NONE;
  }
  return net_val;

}/* dsatetsicall_creg_get_net_reg_status */


/*===========================================================================

FUNCTION ETSICALL_IS_VALID_CELL_INFO

DESCRIPTION
  This function checks if the cell info from NAS and RRC match or not.

DEPENDENCIES
  None
  
RETURN VALUE
  Boolean

SIDE EFFECTS
  None
  
===========================================================================*/
LOCAL boolean etsicall_is_valid_cell_info
(
  const ds_at_ss_info_s_type   *event_info,        /* DS event pointer */
  sys_modem_as_id_e_type         subs_id
)
{
  boolean result = FALSE;

  enum dsat_mismatch_info
  {
    DSAT_NO_MISMATCH,
    DSAT_SYS_MODE_MISMATCH,
    DSAT_LAC_ID_MISMATCH,
    DSAT_PLMN_ID_MISMATCH
  };

  enum dsat_mismatch_info info = DSAT_NO_MISMATCH;
  dsatcmif_servs_state_ms_info *ph_ss_ms_val   = NULL;
  ph_ss_ms_val = dsat_get_base_addr_per_subs(DSAT_SS_PH_MS_VALS, subs_id, TRUE);
  if (NULL == ph_ss_ms_val)
  {
    return FALSE;
  }

  DS_AT_MSG4_HIGH("SYS_MODE(NAS:%d, AS:%d), LAC_ID(NAS:%d, AS:%d)",
                  event_info->sys_mode,
                  event_info->cell_info.as_sys_mode,
                  event_info->sys_id.id.plmn_lac.lac,
                  event_info->cell_info.lac_id);

#ifdef FEATURE_DSAT_LTE
  DS_AT_MSG2_HIGH("lte_tac:%d, cell_info.lac_id:%d",
                  event_info->lte_tac,
                  event_info->cell_info.tac);
#endif /* FEATURE_DSAT_LTE */

  if ((event_info->sys_mode == event_info->cell_info.as_sys_mode) ||
      ((event_info->sys_mode == SYS_SYS_MODE_TDS) &&
       (event_info->cell_info.as_sys_mode == SYS_SYS_MODE_WCDMA)))
  {
    if (TRUE == sys_plmn_match(event_info->sys_id.id.plmn, event_info->cell_info.plmn_id))
    {
      if ( ( (event_info->sys_mode == SYS_SYS_MODE_WCDMA) ||
             (event_info->sys_mode == SYS_SYS_MODE_GSM) ||
             (event_info->sys_mode == SYS_SYS_MODE_TDS) ) &&
           (event_info->sys_id.id.plmn_lac.lac == event_info->cell_info.lac_id) )
      {
        result = TRUE;
      }
#ifdef FEATURE_DSAT_LTE
      else if ( (event_info->sys_mode == SYS_SYS_MODE_LTE) &&
                (event_info->lte_tac == event_info->cell_info.tac) )
      {
        result = TRUE;
      }
#endif /* FEATURE_DSAT_LTE */
      else if ( (event_info->sys_mode == SYS_SYS_MODE_NR5G) &&
	  	         (memcmp(&(event_info->tac_5g),
                  &(event_info->cell_info.tac_5g),
                  sizeof(sys_5g_tac_s_type)) == 0 ) ) 
      {
        result = TRUE;
      }
      else
      {
        info = DSAT_LAC_ID_MISMATCH;
      }
    }
    else
    {
      info = DSAT_PLMN_ID_MISMATCH;
    }
  }
  else
  {
    info = DSAT_SYS_MODE_MISMATCH;
  }
  if (info != DSAT_NO_MISMATCH)
  {
    DS_ATCOP_ERROR_LOG_1("Mismatch info:=d",info);
    ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.pending_cell_info_update = TRUE;
  }
  return result;
}

/*===========================================================================

FUNCTION DSATETSICALL_UPDATE_CREG_LAC_CELL_ID

DESCRIPTION
  This function update CELL ID/LAC ID when COPS command is under process.
  It also set CREG pending flag.

DEPENDENCIES
  None
  
RETURN VALUE
  None

SIDE EFFECTS
  None
  
===========================================================================*/
void dsatetsicall_update_creg_lac_cell_id
(
  const ds_at_cm_ss_event_type  *event_ptr,        /* DS event pointer */
  dsat_stack_id_e_type           stack_id,
  sys_modem_as_id_e_type         subs_id,
  dsat_creg_report_e_type       *report_creg
)
{

#define UPDATE_STATE(prev,latest,flag)\
  if(prev != latest)\
  {\
    *report_creg |= flag;\
    DS_AT_MSG3_HIGH("CREG STATE CHANGE:: prev %d latest %d  flag %d",prev ,latest,flag);\
    prev =  latest;\
  }\
  
#define PREV_PLMN_LAC   ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.plmn_lac
#define PREV_CELL_ID    ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.cell_id
#define PREV_PSC        ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.psc
#ifdef FEATURE_DSAT_LTE
#define PREV_TAC        ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.lte_tac
#define PREV_RAC_MME    ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.lte_rac_or_mme_code
#endif /* FEATURE_DSAT_LTE */

  uint64                        changed_fields = 0;
  dsatcmif_servs_state_ms_info *ph_ss_ms_val   = NULL;

  if ( ( NULL == event_ptr ) ||
       ( FALSE == IS_VALID_STACK_ID(stack_id) ) ||
       ( !IS_VALID_SUBS_ID(subs_id)) )
  {
    DS_AT_MSG3_ERROR("Invalid Arg: event_ptr = %p, stack_id = %d, net_id = %d",
                     event_ptr, stack_id, subs_id);
    return;
  }
  
  ph_ss_ms_val = dsat_get_base_addr_per_subs(DSAT_SS_PH_MS_VALS, subs_id, TRUE);
  if (NULL == ph_ss_ms_val)
  {
    return;
  }

  changed_fields = event_ptr->event_info[stack_id].changed_fields;

  if ((DSAT_SS_SYS_ID_MASK | DSAT_SS_LAC_TAC_RAC_CHGD_MASK) & changed_fields)
  {
    if(DSAT_SS_SYS_ID_MASK & changed_fields)
    {
      UPDATE_STATE(PREV_PLMN_LAC,event_ptr->event_info[stack_id].sys_id.id.plmn_lac.lac,REPORT_CREG_LAC)  
    }
#ifdef FEATURE_DSAT_LTE
    if(DSAT_SS_LAC_TAC_RAC_CHGD_MASK & changed_fields)
    {
      UPDATE_STATE(PREV_TAC,event_ptr->event_info[stack_id].lte_tac,REPORT_CREG_LTE_TAC)
      UPDATE_STATE(PREV_RAC_MME,event_ptr->event_info[stack_id].lte_rac_or_mme_code,REPORT_CREG_LAC_RAC_MME)
    }
#endif /* FEATURE_DSAT_LTE*/
  }
  /*Update Cell-id only when there is a cell-id change or the serving system 
    is also updated to system on which cell info is received from.*/
   if(((DSAT_SS_CELL_INFO_MASK & changed_fields) &&
     (TRUE == etsicall_is_valid_cell_info(&event_ptr->event_info[stack_id], subs_id)))
     || ((DSAT_SS_SYS_MODE_MASK & changed_fields) && 
      ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.pending_cell_info_update == TRUE))
  {
    UPDATE_STATE(PREV_CELL_ID,event_ptr->event_info[stack_id].cell_info.cell_id,REPORT_CREG_CELL_ID)
    UPDATE_STATE(PREV_PSC,event_ptr->event_info[stack_id].cell_info.psc,REPORT_CREG_CELL_PSC)
    ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.pending_cell_info_update = FALSE;
  }
    
}/*dsatetsicall_update_creg_lac_cell_id*/


/*===========================================================================

FUNCTION DSATETSICALL_CREG_STATE_MACHINE

DESCRIPTION
  This function generates the unsolicited result code for registration
  commands +CREG and +CGREG.  The command parameter <n> controls whether
  results are presented or suppressed.

DEPENDENCIES
  None
  
RETURN VALUE
  None

SIDE EFFECTS
  None
  
===========================================================================*/
void dsatetsicall_creg_state_machine
(
  const ds_at_cm_ss_event_type * event_ptr,        /* DS event pointer */
  dsat_stack_id_e_type           stack_id,
  sys_modem_as_id_e_type         subs_id
)
{
#define UPDATE_STATE_CHANGE(prev,latest,flag)\
    if(prev != latest)\
    {\
      report_creg |= flag;\
      DS_AT_MSG3_HIGH("STATE CHANGE:: prev %d latest %d  flag %d",prev ,latest,flag);\
      prev =  latest;\
    }\

#define IS_STATE_ULOCK(reg_rej_st)\
        ((dsat_rej_srv_domain == SYS_SRV_DOMAIN_CS_ONLY && reg_rej_st == DSAT_CREG_STAT_CNG_PS_LCK)||\
        (dsat_rej_srv_domain == SYS_SRV_DOMAIN_PS_ONLY && reg_rej_st == DSAT_CREG_STAT_CNG_CS_LCK))\

#define PREV_CS_DOMAIN  ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.net_domain[DSAT_NET_REG_DOMAIN_CS]
#define PREV_PS_DOMAIN  ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.net_domain[DSAT_NET_REG_DOMAIN_PS]

  dsat_creg_report_e_type      report_creg = REPORT_NONE;
  sys_srv_domain_e_type        dsat_rej_srv_domain;
  sys_roam_status_e_type       roaming;
  uint64                       changed_fields = 0;
  net_reg_status_e_type        net_val = DSAT_NET_REG_NONE; 
  sys_sim_state_e_type         sim_state;
  sys_srv_domain_e_type        srv_capability;
  dsatcmif_servs_state_ms_info  *ph_ss_ms_val   = NULL;
  boolean                      ps_data_suspend;
  dsat_subs_mode_e_type        subs_mode;

  ph_ss_ms_val = dsat_get_base_addr_per_subs(DSAT_SS_PH_MS_VALS, subs_id, TRUE);

  if ( ( NULL == event_ptr ) ||
       ( FALSE == IS_VALID_STACK_ID(stack_id) ) ||
       ( NULL == ph_ss_ms_val ) )
  {
    DS_AT_MSG3_ERROR("Invalid Arg: event_ptr = %p, stack_id = %d, net_id = %d, subs_id = %d",
                     event_ptr, stack_id,  subs_id);
    return;
  }

  dsat_rej_srv_domain = event_ptr->event_info[stack_id].srv_domain;
  roaming = event_ptr->event_info[stack_id].roam_status;
  net_val = dsatetsicall_creg_get_net_reg_status(event_ptr,stack_id,subs_id);
  sim_state = event_ptr->event_info[stack_id].sim_state;
  srv_capability = event_ptr->event_info[stack_id].srv_capability;
  changed_fields = event_ptr->event_info[stack_id].changed_fields;
  ps_data_suspend = event_ptr->event_info[stack_id].ps_data_suspend;
  
  if(CM_SS_EVENT_REG_REJECT == event_ptr->event)
  {
   /* Moved CREG state into Registration denied till camped indication recevied */
    dsat_rej_srv_domain = event_ptr->event_info[stack_id].reg_reject_info.reject_srv_domain;
    DS_AT_MSG1_HIGH(" Reg_reg_state %d ", ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.reg_rej_state);
    if( dsat_rej_srv_domain == SYS_SRV_DOMAIN_CS_ONLY )
    {
     /* Update CS reject cause */
      UPDATE_STATE_CHANGE(PREV_CS_DOMAIN,DSAT_NET_REG_DENIED,REPORT_CREG)
      if(ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.reg_rej_state == DSAT_CREG_STAT_CNG_PS_LCK ||
         ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.reg_rej_state == DSAT_CREG_STAT_CNG_CSPS_LCK)
      {
        ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.reg_rej_state = DSAT_CREG_STAT_CNG_CSPS_LCK;
      }else
      {
        ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.reg_rej_state = DSAT_CREG_STAT_CNG_CS_LCK;
      }
    }
    else if( dsat_rej_srv_domain == SYS_SRV_DOMAIN_PS_ONLY )
    {
      /* Update PS reject cause */
      UPDATE_STATE_CHANGE(PREV_PS_DOMAIN,DSAT_NET_REG_DENIED,REPORT_CGREG)
      if(ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.reg_rej_state == DSAT_CREG_STAT_CNG_CS_LCK ||
         ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.reg_rej_state == DSAT_CREG_STAT_CNG_CSPS_LCK)
      {
        ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.reg_rej_state = DSAT_CREG_STAT_CNG_CSPS_LCK;
      }else
      {
        ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.reg_rej_state = DSAT_CREG_STAT_CNG_PS_LCK;
      }
    }
    else if(dsat_rej_srv_domain == SYS_SRV_DOMAIN_CS_PS)
    {
        /* Update both reject causes */
      UPDATE_STATE_CHANGE(PREV_CS_DOMAIN ,DSAT_NET_REG_DENIED,REPORT_CREG)
      UPDATE_STATE_CHANGE(PREV_PS_DOMAIN,DSAT_NET_REG_DENIED,REPORT_CGREG)
      ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.reg_rej_state = DSAT_CREG_STAT_CNG_CSPS_LCK;
    }
  }
  else if(CM_SS_EVENT_SRV_CHANGED == event_ptr->event)
  {
    dsatetsicall_update_creg_lac_cell_id(event_ptr, stack_id, subs_id, &report_creg);
    if(DSAT_SS_SIM_STATE_MASK & changed_fields)
    {
      if ( sim_state == SYS_SIM_STATE_CS_INVALID )
      {
        UPDATE_STATE_CHANGE(PREV_CS_DOMAIN,DSAT_NET_REG_DENIED,REPORT_CREG)

      if(ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.reg_rej_state == DSAT_CREG_STAT_CNG_PS_LCK ||
         ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.reg_rej_state == DSAT_CREG_STAT_CNG_CSPS_LCK)
        {
          ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.reg_rej_state = DSAT_CREG_STAT_CNG_CSPS_LCK;
        }else
        {
          ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.reg_rej_state = DSAT_CREG_STAT_CNG_CS_LCK;
        }
      }
      else if ( sim_state == SYS_SIM_STATE_PS_INVALID )
      {
        UPDATE_STATE_CHANGE(PREV_PS_DOMAIN,DSAT_NET_REG_DENIED,REPORT_CGREG)
        if(ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.reg_rej_state == DSAT_CREG_STAT_CNG_CS_LCK ||
           ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.reg_rej_state == DSAT_CREG_STAT_CNG_CSPS_LCK)
        {
          ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.reg_rej_state = DSAT_CREG_STAT_CNG_CSPS_LCK;
        }
        else
        {
          ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.reg_rej_state = DSAT_CREG_STAT_CNG_PS_LCK;
        }
      }
      else if ( sim_state == SYS_SIM_STATE_CS_PS_INVALID )
      {
        UPDATE_STATE_CHANGE(PREV_CS_DOMAIN,DSAT_NET_REG_DENIED,REPORT_CREG)
        UPDATE_STATE_CHANGE(PREV_PS_DOMAIN,DSAT_NET_REG_DENIED,REPORT_CGREG)
        ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.reg_rej_state = DSAT_CREG_STAT_CNG_CSPS_LCK;
      }
    }
    /* Check for ps_data_suspend value in addition to the PS_DATA_SUSPEND_MASK. 
       PS data is suspended when ps_data_suspend is 1 */
    if((DSAT_SS_PS_DATA_SUSPEND_MASK & changed_fields) && (ps_data_suspend == TRUE))
    {
      if(ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.reg_rej_state == DSAT_CREG_STAT_CNG_CS_LCK ||
         ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.reg_rej_state == DSAT_CREG_STAT_CNG_CSPS_LCK)
      {
        ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.reg_rej_state = DSAT_CREG_STAT_CNG_CSPS_LCK;
      }
      else
      {
        ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.reg_rej_state = DSAT_CREG_STAT_CNG_PS_LCK;
      }
    }

    if((ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.reg_rej_state != DSAT_CREG_STAT_CNG_UNLCK 
        && ((DSAT_SS_PS_DATA_SUSPEND_MASK & changed_fields) && (ps_data_suspend == FALSE)))
        || (ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.reg_rej_state != DSAT_CREG_STAT_CNG_UNLCK &&
        !(DSAT_SS_PS_DATA_SUSPEND_MASK & changed_fields)) )
    {
      if(event_ptr->event_info[stack_id].srv_status == SYS_SRV_STATUS_SRV)
      {
        if(dsat_rej_srv_domain == SYS_SRV_DOMAIN_CS_PS || dsat_rej_srv_domain == SYS_SRV_DOMAIN_NO_SRV)
        {
          ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.reg_rej_state = DSAT_CREG_STAT_CNG_UNLCK;
        }
        else if(dsat_rej_srv_domain == SYS_SRV_DOMAIN_CS_ONLY)
        {
          if(ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.reg_rej_state == DSAT_CREG_STAT_CNG_CSPS_LCK)
          {
            ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.reg_rej_state = DSAT_CREG_STAT_CNG_PS_LCK;
          }
          else if(ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.reg_rej_state == DSAT_CREG_STAT_CNG_CS_LCK)
          {
            ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.reg_rej_state = DSAT_CREG_STAT_CNG_UNLCK;
          }
        }
        else if(dsat_rej_srv_domain == SYS_SRV_DOMAIN_PS_ONLY)
        {
          if(ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.reg_rej_state == DSAT_CREG_STAT_CNG_CSPS_LCK)
          {
            ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.reg_rej_state = DSAT_CREG_STAT_CNG_CS_LCK;
          }
          else if(ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.reg_rej_state == DSAT_CREG_STAT_CNG_PS_LCK)
          {
            ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.reg_rej_state = DSAT_CREG_STAT_CNG_UNLCK;
          }
        }
      }
      else if(event_ptr->event_info[stack_id].srv_status == SYS_SRV_STATUS_NO_SRV && 
	  	                 dsat_rej_srv_domain == SYS_SRV_DOMAIN_NO_SRV)
      {
        ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.reg_rej_state = DSAT_CREG_STAT_CNG_UNLCK;
      }
    }

    if(SYS_SRV_DOMAIN_CAMPED == dsat_rej_srv_domain)
    {
       /* MS found the right system but not yet registered or attached. */
       /* Dont report CREG but clear CREG state */
       ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.reg_rej_state = DSAT_CREG_STAT_CNG_UNLCK;
         /*If cops in Deregistration state then creg must be No service and reg_rej */
       if ( DSAT_COPS_MODE_AUTO == (dsat_num_item_type)dsatutil_get_val(
                             DSATETSI_EXT_ACT_COPS_ETSI_IDX,subs_id,0,MIX_NUM_TYPE))
       {
         if(ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.net_domain[DSAT_NET_REG_DOMAIN_PS] == DSAT_NET_REG_NONE ||
            DSAT_SS_SYS_MODE_MASK & changed_fields)
         {
             /*If creg is in No searching mode due to cfun 0 or cops 2 then move creg to Searching */
           UPDATE_STATE_CHANGE(PREV_PS_DOMAIN,DSAT_NET_REG_SEARCHING ,REPORT_CGREG)
         }
         if(ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.net_domain[DSAT_NET_REG_DOMAIN_CS] == DSAT_NET_REG_NONE ||
            DSAT_SS_SYS_MODE_MASK & changed_fields)
         {
            UPDATE_STATE_CHANGE(PREV_CS_DOMAIN,DSAT_NET_REG_SEARCHING ,REPORT_CREG)
         }
       }
    }
    else if(ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.reg_rej_state == DSAT_CREG_STAT_CNG_UNLCK ||
               (IS_STATE_ULOCK(ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.reg_rej_state)))
    {
      dsat_num_item_type cemode = (dsat_num_item_type)dsatutil_get_val( DSATETSI_EXT_CEMODE_IDX,0,0,NUM_TYPE);

      switch (event_ptr->event_info[stack_id].srv_status)
      {
        case SYS_SRV_STATUS_SRV:
        {
          if(sim_state != SYS_SIM_STATE_NOT_AVAILABLE)
          {
          switch(dsat_rej_srv_domain)
          {
            case SYS_SRV_DOMAIN_CS_ONLY:
             if( SYS_ROAM_STATUS_OFF == roaming )
             {
               UPDATE_STATE_CHANGE(PREV_CS_DOMAIN,DSAT_NET_REG_HOME ,REPORT_CREG)
             }else
             {
               UPDATE_STATE_CHANGE(PREV_CS_DOMAIN,DSAT_NET_REG_ROAMING  ,REPORT_CREG)
             }
               /*SET PS to DSAT_NET_REG_SEARCHING*/
             if(srv_capability == SYS_SRV_DOMAIN_CS_PS)
             {
               UPDATE_STATE_CHANGE(PREV_PS_DOMAIN,DSAT_NET_REG_SEARCHING ,REPORT_CGREG)
             }else if(PREV_PS_DOMAIN != DSAT_NET_REG_DENIED)
             {
               UPDATE_STATE_CHANGE(PREV_PS_DOMAIN,DSAT_NET_REG_NONE ,REPORT_CGREG)
             }
             
            break;
            case SYS_SRV_DOMAIN_PS_ONLY:
             if( SYS_ROAM_STATUS_OFF == roaming )
             {
               UPDATE_STATE_CHANGE(PREV_PS_DOMAIN,DSAT_NET_REG_HOME ,REPORT_CGREG)
             }else
             {
               UPDATE_STATE_CHANGE(PREV_PS_DOMAIN,DSAT_NET_REG_ROAMING  ,REPORT_CGREG)
             }
               /*SET CS to DSAT_NET_REG_SEARCHING*/
             if(srv_capability == SYS_SRV_DOMAIN_CS_PS)
             {
               UPDATE_STATE_CHANGE(PREV_CS_DOMAIN,DSAT_NET_REG_SEARCHING ,REPORT_CREG)
             }else if(PREV_CS_DOMAIN != DSAT_NET_REG_DENIED)
             {
               UPDATE_STATE_CHANGE(PREV_CS_DOMAIN,DSAT_NET_REG_NONE,REPORT_CREG)
             }
              
            break;
            case SYS_SRV_DOMAIN_CS_PS:
             if( SYS_ROAM_STATUS_OFF == roaming )
             {
               UPDATE_STATE_CHANGE(PREV_PS_DOMAIN,DSAT_NET_REG_HOME ,REPORT_CGREG)
               UPDATE_STATE_CHANGE(PREV_CS_DOMAIN,DSAT_NET_REG_HOME ,REPORT_CREG)
             }else
             {
               UPDATE_STATE_CHANGE(PREV_PS_DOMAIN,DSAT_NET_REG_ROAMING  ,REPORT_CGREG)
               UPDATE_STATE_CHANGE(PREV_CS_DOMAIN,DSAT_NET_REG_ROAMING  ,REPORT_CREG)
             }
             break;
             
            default:
             break;
          }
        }
        }
        break;
        case SYS_SRV_STATUS_LIMITED:
        case SYS_SRV_STATUS_LIMITED_REGIONAL:
        {
          DS_AT_MSG1_HIGH(" Net val %d ",net_val); 
          switch(dsat_rej_srv_domain)
          {
            case SYS_SRV_DOMAIN_CS_ONLY:
              UPDATE_STATE_CHANGE(PREV_CS_DOMAIN,net_val ,REPORT_CREG)
            break;
            case SYS_SRV_DOMAIN_PS_ONLY:
              UPDATE_STATE_CHANGE(PREV_PS_DOMAIN,net_val ,REPORT_CGREG)
              
            break;
            case SYS_SRV_DOMAIN_CS_PS:
            case SYS_SRV_DOMAIN_NO_SRV:
              switch(cemode)
              {
                case DSAT_EPS_PS_MODE_1:
                case DSAT_EPS_PS_MODE_2:
                  UPDATE_STATE_CHANGE(PREV_PS_DOMAIN,net_val  ,REPORT_CGREG)
                  break;
                default:
              UPDATE_STATE_CHANGE(PREV_PS_DOMAIN,net_val  ,REPORT_CGREG)
              UPDATE_STATE_CHANGE(PREV_CS_DOMAIN,net_val  ,REPORT_CREG)
                  break;
              }
            break;
            default:
            break;
          }
        }
        break;
        case SYS_SRV_STATUS_NO_SRV:
        case SYS_SRV_STATUS_PWR_SAVE:
        {
          subs_mode = cmif_determine_subs_mode(event_ptr);
          if(subs_mode == DSAT_SUB_SVLTE)
          {
            /* We will come here only
               if SYS_SYS_MODE_NO_SRV [at MAIN] and SYS_SYS_MODE_LTE[at HYBR] or
               if SYS_SYS_MODE_CDMA [at MAIN] and SYS_SYS_MODE_LTE[at HYBR] or 
               if SYS_SYS_MODE_CDMA [at MAIN] and SYS_SYS_MODE_NO_SRV[at HYBR].

               We will update CEREG only for stack HYBR and if sys_mode is LTE or NO SRV */
            if((stack_id == DSAT_STACK_HYBR) && 
               (event_ptr->event_info[DSAT_STACK_HYBR].sys_mode == SYS_SYS_MODE_LTE ||
                event_ptr->event_info[DSAT_STACK_HYBR].sys_mode == SYS_SYS_MODE_NO_SRV))
            {
              UPDATE_STATE_CHANGE(PREV_PS_DOMAIN,net_val  ,REPORT_CGREG)
            }
            else
            {
              UPDATE_STATE_CHANGE(PREV_CS_DOMAIN,net_val  ,REPORT_CREG)
            }
          }
          else
          {
            switch(cemode)
            {
               case DSAT_EPS_PS_MODE_1:
               case DSAT_EPS_PS_MODE_2:
               UPDATE_STATE_CHANGE(PREV_PS_DOMAIN,net_val  ,REPORT_CGREG)
               break;
               default:
               UPDATE_STATE_CHANGE(PREV_PS_DOMAIN,net_val  ,REPORT_CGREG)
               UPDATE_STATE_CHANGE(PREV_CS_DOMAIN,net_val  ,REPORT_CREG)
               break;
             }
           }
           break;
         }
        default:
         break;
      }
    }
  }

  /* Check pending flag(While Cops is under process) */
  if( ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.cops_pending_report_creg)
  {
    report_creg = report_creg | ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.cops_pending_report_creg;
    DS_AT_MSG2_HIGH(" Report Creg %d Cops Pending CREG  %d",
        report_creg,
        ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.cops_pending_report_creg);
 
    ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.cops_pending_report_creg = REPORT_NONE;
  }
  if(report_creg)
  {
    if (DSAT_DL_VALIDATE_SYMBOL_ADDR(dsatdl_vtable.dsatetsicall_report_creg_result_fp) )
    {
      dsatdl_vtable.dsatetsicall_report_creg_result_fp(stack_id, subs_id, report_creg);
    }
  }

 return;
} /* dsatetsicall_creg_state_machine */






/*===========================================================================

FUNCTION DSATETSICALL_CALL_EVENT_MNG_CALLS_CONF_EX

DESCRIPTION
  This function is called by dsatcmif_cm_call_event_handler when CM reports 
  the CM_CALL_EVENT_MNG_CALLS_CONF event.
  For ATCOP originated events: 
    On success needs to update state indicating no longer waiting for this 
    confirmation and on failure must issue CME ERROR result code.
  For other clients:
    On success of hold call(s) command needs to update held calls info so 
    any subsequent AT+CHLD=0 (release all held calls) command will know number
    of END events to expect before giving result code.

DEPENDENCIES
  None

RETURN VALUE
  DSAT_CMD_ERR_RSP : if CM reports failure.
  DSAT_ASYNC_EVENT:  otherwise.

SIDE EFFECTS
  None
  
===========================================================================*/
/* ARGSUSED */
dsat_result_enum_type dsatetsicall_call_event_mng_calls_conf_ex
(
  ds_at_cm_call_event_type *call_event,  /* Call event pointer */
  sys_modem_as_id_e_type    subs_id      /* Subsription ID */
)
{
  dsat_result_enum_type result = DSAT_ASYNC_EVENT;
  uint8 num_calls = 0;
  cm_call_id_type call_ids[CM_CALL_ID_MAX];      
  boolean temp_stg = FALSE;
  dsatetsicall_call_state_da_info  *call_da_val = NULL;


  call_da_val = dsat_get_base_addr_per_subs(DSAT_CALL_DA_VALS, subs_id, TRUE);
  if (NULL == call_da_val)
  {
    return DSAT_ASYNC_EVENT;
  }

  if(!IS_ETSI_MODE(dsatcmdp_get_current_mode_per_subs(subs_id)))
  {
    DS_AT_MSG0_MED("Not handling for CDMA events");
    return DSAT_ASYNC_EVENT;
  }

  DS_AT_MSG2_MED("evt_mng: call id %d, sups_type %d",
           call_event->event_info.call_id,
           call_event->event_info.sups_type);

  /* Generate debug message call list */
  etsicall_show_call_lists(subs_id);


  if ( call_event->event_info.requesting_client_id != CM_CLIENT_TYPE_ATCOP )
  {
    if ( call_event->event_info.dsat_mode_info.info.gw_cs_call.call_ss_success )
    {
      switch ( call_event->event_info.sups_type )
      {
        case CM_CALL_SUPS_TYPE_ACTIVE_CALL_REL:
          /* 1,SEND - Release any & all active calls and accept other call 
             (held or waiting) */
          if ( !call_da_val->etsicall_wait_call_present )
          {
            /* If no waiting call is present move held calls to active call 
               list, excluding none. */
            (void)etsicall_move_calls( &call_da_val->etsicall_num_held_calls,
                                        call_da_val->etsicall_held_call_ids,
                                       &call_da_val->etsicall_num_active_calls,
                                        call_da_val->etsicall_active_call_ids,
                                       CM_CALL_ID_INVALID );
          }
          break;

        case CM_CALL_SUPS_TYPE_HOLD_CALL:
          /* 2,SEND - Place all active calls on hold and
             accept another call (held or waiting) */

          /* If held call(s) but no waiting call move held call(s) to temporary 
             storage */
          if ( !call_da_val->etsicall_wait_call_present &&
                call_da_val->etsicall_num_held_calls != 0 )
          {
            (void)etsicall_move_calls( &call_da_val->etsicall_num_held_calls,
                                        call_da_val->etsicall_held_call_ids,
                                       &num_calls,
                                       call_ids,
                                       CM_CALL_ID_INVALID );

            temp_stg = TRUE;
          }

          /* Move active calls to held call list, excluding none */
          (void)etsicall_move_calls( &call_da_val->etsicall_num_active_calls,
                                      call_da_val->etsicall_active_call_ids,
                                     &call_da_val->etsicall_num_held_calls,
                                      call_da_val->etsicall_held_call_ids,
                                     CM_CALL_ID_INVALID );

          /* Temporarily stored (previously held) calls should be moved to 
             active calls storage */
          if ( temp_stg )
          {
            (void)etsicall_move_calls( &num_calls,
                                       call_ids,
                                       &call_da_val->etsicall_num_active_calls,
                                        call_da_val->etsicall_active_call_ids,
                                       CM_CALL_ID_INVALID );
          }
          break;

        case CM_CALL_SUPS_TYPE_SELECT_CALL_X:
          /* 2x,SEND - Place all active calls on hold except x
             with which communication is still established. 
             As CM's enum cm_call_sups_type_e_type has no value to describe 
             the 'Entering "Directory Number"' case in 22.030 section 6.5.5.1 
             dsatcmif.c's cmif_call_event_cb_func() will use this case to 
             handle it */

          /* Move active calls to held call list, excluding selected call id */
          (void)etsicall_move_calls( 
            &call_da_val->etsicall_num_active_calls,
             call_da_val->etsicall_active_call_ids,
            &call_da_val->etsicall_num_held_calls,
             call_da_val->etsicall_held_call_ids,
            call_event->event_info.call_id );
          break;

        case CM_CALL_SUPS_TYPE_MULTIPARTY_CALL:
          /* 3,SEND - Add a held call to the conversation,
             Multiparty call */
          /* Move held calls to active call list, excluding none */
          (void)etsicall_move_calls( &call_da_val->etsicall_num_held_calls,
                                      call_da_val->etsicall_held_call_ids,
                                     &call_da_val->etsicall_num_active_calls,
                                      call_da_val->etsicall_active_call_ids,
                                     CM_CALL_ID_INVALID );
          break;

        case CM_CALL_SUPS_TYPE_CALL_DEFLECTION:
          /* 4 * DN SEND - Deflect an incoming call */
          call_da_val->etsicall_wait_call_present = FALSE;
          break;

        default:
          break;
      }
    }
  }
  
  /* Generate debug message call list */
  etsicall_show_call_lists(subs_id);
  return result;
} /* dsatetsicall_call_event_mng_calls_conf_ex */


/*===========================================================================

FUNCTION DSATETSICALL_CALL_EVENT_CONNECT_EX

DESCRIPTION
  This function is called by dsatcmif_cm_call_event_handler when CM reports 
  the CM_CALL_EVENT_CONNECT event. It adds the call id connected to the active
  calls list of our state info and if a +CHLD command is pending and no 
  further events are expected gives result code.

DEPENDENCIES
  None

RETURN VALUE
  DSAT_OK :          if +CHLD command processing complete.
  DSAT_ASYNC_EVENT:  otherwise.

SIDE EFFECTS
  None
  
===========================================================================*/
/* ARGSUSED */
dsat_result_enum_type dsatetsicall_call_event_connect_ex
(
  ds_at_cm_call_event_type*  call_event,     /* call event pointer         */
  sys_modem_as_id_e_type     subs_id              /* Subsription ID */
)
{
  dsat_result_enum_type result = DSAT_ASYNC_EVENT;
  dsatetsicall_call_state_da_info  *call_da_val = NULL;
  int seq_num;

  call_da_val = dsat_get_base_addr_per_subs(DSAT_CALL_DA_VALS, subs_id, TRUE);
  if (NULL == call_da_val)
  {
    return DSAT_ASYNC_EVENT;
  }
#ifdef FEATURE_ETSI_PBM
    /* Change last dial record/incoming call for this call ID to be connected.
       This moved into non-voice block as OEMCM makes entry for voice calls
       and duplicate entries were created */
    dsatme_last_call_connected(subs_id);
#endif /* defined(FEATURE_ETSI_PBM)  */

  /* Update +CIND indicators */
  (void)dsatetsime_change_indicator_state( DSAT_CIND_INDEX_CALLSETUP,
                                           DSAT_CIND_CSETUP_NONE, subs_id);
  (void)dsatetsime_change_indicator_state( DSAT_CIND_INDEX_CALL, 1, subs_id);

  if ( (call_event->event_info.call_type != CM_CALL_TYPE_VOICE) &&
       (call_event->event_info.call_type != CM_CALL_TYPE_EMERGENCY) &&
       (call_event->event_info.call_type != CM_CALL_TYPE_VT))
  {
    return result;
  }  

  DS_AT_MSG1_MED("evt_conn: call id %d", call_event->event_info.call_id);

  /* Generate debug message call list */
  etsicall_show_call_lists(subs_id);

  /* Search for and if found remove call id from etsicall_active_call_ids */
  if ( etsicall_search_call_list(&call_da_val->etsicall_num_active_calls,
                                  call_da_val->etsicall_active_call_ids,
                                 call_event->event_info.call_id,
                                 TRUE) )
  {
    DS_AT_MSG0_HIGH("Call id was already in active call list");
  }


  /* Search for and if found remove call id from etsicall_held_call_ids */
  if ( etsicall_search_call_list(&call_da_val->etsicall_num_held_calls,
                                  call_da_val->etsicall_held_call_ids,
                                 call_event->event_info.call_id,
                                 TRUE) )
  {
    DS_AT_MSG0_HIGH("CONNECT event's call id was already in held call list");
  }

  if ( call_da_val->etsicall_wait_call_present &&
       call_da_val->etsicall_wait_call_id == call_event->event_info.call_id )
  {
    call_da_val->etsicall_wait_call_present = FALSE;
  }

  if ( call_da_val->etsicall_num_active_calls + 1 > CM_CALL_ID_MAX )
  {
    DS_AT_MSG0_HIGH("etsicall_num_active_calls would exceed bound");
  }
  else
  {
    /* Add call id to active call list */
    call_da_val->etsicall_active_call_ids[call_da_val->etsicall_num_active_calls++] = 
      call_event->event_info.call_id;
  }

  /* Generate debug message call list */
  etsicall_show_call_lists(subs_id);

  /* Clear the call id before connect */
  if(call_da_val->call_info_before_connect.call_id == call_event->event_info.call_id)
  {
    call_da_val->call_info_before_connect.call_id = CM_CALL_ID_INVALID;
    call_da_val->call_info_before_connect.info_type = CM_CALL_MODE_INFO_NONE;	
  }

  /* Save linked call id for conference call */
  if((etsicall_cmd_pending[subs_id] & (CMD_CONF | CMD_CHLD3 )) == (CMD_CONF | CMD_CHLD3))
  {
    call_da_val->conf_linked_call_id = call_event->event_info.call_id;
    seq_num = dsatact_callid_to_seqnum(subs_id, call_event->event_info.call_id);
    if(seq_num != CALL_SEQNUM_INVALID)
    {
      /* Tagging conference call id as conference call */
      call_da_val->dsat_seqnum_callid[seq_num - 1].is_conf_participant = TRUE;
    }
    DS_AT_MSG2_HIGH("call id for conference call %d seq_num %d", call_da_val->conf_linked_call_id, seq_num );
  }

  if( dsatcmif_is_voice_call_type (call_event->event_info.call_type ) )
  {	
    /* Store mode info type */
    if(call_event->event_info.call_id < CM_CALL_ID_MAX)
    {
      call_da_val->mode_info[call_event->event_info.call_id] = call_event->event_info.dsat_mode_info.info_type;
    }
  }

  if(etsicall_cmd_pending[subs_id] == CMD_NONE)
  {
    result = dsatvoice_call_event_connect(subs_id, 
                                          &call_event->event_info);
  }

  return result;
} /* dsatetsicall_call_event_connect_ex */



/*===========================================================================

FUNCTION DSATETSICALL_CALL_EVENT_END_EX

DESCRIPTION
  This function is called by dsatcmif_cm_call_event_handler when CM reports 
  the CM_CALL_EVENT_MNG_CALLS_CONF event and removes the call id ended from 
  our call state info.

DEPENDENCIES
  None

RETURN VALUE
  DSAT_CMD_ERR_RSP : if CM reports failure.
  DSAT_ASYNC_EVENT:  otherwise.

SIDE EFFECTS
  None
  
===========================================================================*/
/* ARGSUSED */
dsat_result_enum_type dsatetsicall_call_event_end_ex
(
  ds_at_cm_call_event_type *call_event, /* Call event pointer */
  sys_modem_as_id_e_type    subs_id     /* Subsription ID */
)
{
  dsat_result_enum_type            result = DSAT_ASYNC_EVENT;
  cm_call_id_type                  call_id;
  dsatetsicall_call_state_da_info *call_da_val = NULL;
  int i = 0;
  #ifdef FEATURE_ETSI_PBM
  dsatme_pbm_state_ms_info  *pbm_ms_val = NULL;
#endif /* FEATURE_ETSI_PBM */

  call_event->event_info.report_cssu          = FALSE;
  call_event->event_info.is_call_id_found     = FALSE;
  call_event->event_info.is_call_among_active = FALSE;

  call_da_val = dsat_get_base_addr_per_subs(DSAT_CALL_DA_VALS, subs_id, TRUE);
  if (NULL == call_da_val)
  {
    return DSAT_ASYNC_EVENT;
  }

  call_id = call_event->event_info.call_id;

  DS_AT_MSG1_MED("evt_end: call id %d", call_id);

#ifdef FEATURE_ETSI_PBM
  /* Save incoming call in either received/missed phone book 
     Save call duration in case of outgoing call.
     Outgoing call is already saved to phonebook during dialing */
  pbm_ms_val = dsat_get_base_addr_per_subs(DSAT_PBM_MS_VALS, subs_id, TRUE);
  if(NULL != pbm_ms_val &&
     NULL != pbm_ms_val->last_call_rec_ptr &&
     pbm_ms_val->last_call_rec_ptr->state != LAST_CALL_NONE)
  {
    dsatme_last_call_save(subs_id);
  }
#endif /* defined(FEATURE_ETSI_PBM) */

  /* Update +CIND callsetup indicator */
  (void)dsatetsime_change_indicator_state( DSAT_CIND_INDEX_CALLSETUP,
                                           DSAT_CIND_CSETUP_NONE, subs_id);
  /* Update +CIND call index indicator */
  (void)dsatetsime_change_indicator_state( DSAT_CIND_INDEX_CALL, 0, subs_id);

  /* Generate debug message call list */
  etsicall_show_call_lists(subs_id);

  if ( call_event->event_info.call_type == CM_CALL_TYPE_VOICE ||
       call_event->event_info.call_type == CM_CALL_TYPE_EMERGENCY ||
       call_event->event_info.call_type == CM_CALL_TYPE_VT)
  {
    /* Search for and if found remove call id from etsicall_active_call_ids and 
       decrement etsicall_num_active_calls */
    if ( etsicall_search_call_list(&call_da_val->etsicall_num_active_calls,
                                    call_da_val->etsicall_active_call_ids,
                                   call_id,
                                   TRUE) )
    {
      call_event->event_info.is_call_id_found = TRUE;
      call_event->event_info.is_call_among_active = TRUE;
    }
    /* If not found in active call list search for and if found remove call id 
       from etsicall_held_call_ids and decrement etsicall_num_held_calls */
    else if ( etsicall_search_call_list(
      &call_da_val->etsicall_num_held_calls,
       call_da_val->etsicall_held_call_ids,
      call_id,
      TRUE) )
    {
      call_event->event_info.is_call_id_found = TRUE;
      call_event->event_info.report_cssu = TRUE;
    } 
    /* If not found in active or held calls lists check wait call */
    else if ( call_da_val->etsicall_wait_call_present && 
              call_da_val->etsicall_wait_call_id == call_id )
    {
      call_da_val->etsicall_wait_call_present = FALSE;
      call_event->event_info.is_call_id_found = TRUE;
    }
#ifdef FEATURE_DUAL_ACTIVE
    /* Lastly search in local held calls list and if found remove call id from
       etsicall_local_held_call_ids and decrement etsicall_num_local_held_calls */
    else if ( etsicall_search_call_list(
      &call_da_val->etsicall_num_local_held_calls,
       call_da_val->etsicall_local_held_call_ids,
      call_id,
      TRUE) )
    {
      call_event->event_info.is_call_id_found = TRUE;
    }
#endif /* FEATURE_DUAL_ACTIVE */
    else
    {
      DS_AT_MSG0_HIGH("END event's call id not found");
    }

    /* Check if Call End event is for Conference Call */
    if(call_da_val->conf_linked_call_id == call_id && call_da_val->etsicall_num_participant_in_conf > 0 &&
       call_da_val->handover_complete == FALSE)
    {
      /* Clear the participants info */
      DS_AT_MSG1_HIGH("Participants info cleared for conf call id %d", call_da_val->conf_linked_call_id);
      call_da_val->etsicall_num_participant_in_conf = 0;
      call_da_val->conf_linked_call_id = CM_CALL_ID_INVALID;
      for(i = 0; i < CM_CALL_ID_MAX; i++)
      {
        call_da_val->conf_participant_info[i].dsat_call_id = CM_CALL_ID_INVALID;
        call_da_val->conf_participant_info[i].seq_number = CALL_SEQNUM_INVALID;
        call_da_val->conf_participant_info[i].user_uri_len = 0;
        call_da_val->conf_participant_info[i].user_uri[0] = '\0';	
        call_da_val->conf_participant_info[i].status = MMODE_QMI_CALL_STATUS_DISCONNECTED;
      }
    }

    /* Generate debug message call list */
    etsicall_show_call_lists(subs_id);

    /* Clear the call id before connect */
    if(call_da_val->call_info_before_connect.call_id == call_id)
    {
      call_da_val->call_info_before_connect.call_id = CM_CALL_ID_INVALID;
      call_da_val->call_info_before_connect.info_type = CM_CALL_MODE_INFO_NONE;	
    }
  }
  return result;
} /* dsatetsicall_call_event_end_ex */

/*===========================================================================

FUNCTION DSATETSICALL_CALL_EVENT_INCOM

DESCRIPTION
  This function is called by dsatcmif_cm_call_event_handler when CM reports 
  the CM_CALL_EVENT_INCOM event and adds the waiting call id to our call state
  info.

DEPENDENCIES
  None

RETURN VALUE
  DSAT_CMD_ERR_RSP : if CM reports failure.
  DSAT_ASYNC_EVENT:  otherwise.

SIDE EFFECTS
  None
  
===========================================================================*/
dsat_result_enum_type dsatetsicall_call_event_incom
(
  ds_at_cm_call_event_type*  call_event,    /* DS Command pointer         */
  sys_modem_as_id_e_type     subs_id             /* Subsription ID */
)
{
  dsat_result_enum_type result = DSAT_ASYNC_EVENT;
  dsatetsicall_call_state_da_info  *call_da_val = NULL;
  
  call_da_val = dsat_get_base_addr_per_subs(DSAT_CALL_DA_VALS, subs_id, TRUE);
  if (NULL == call_da_val)
  {
    return DSAT_ASYNC_EVENT;
  }

  DS_AT_MSG1_MED("evt_incom: call id %d",call_event->event_info.call_id);

  /* Update +CIND callsetup indicator */
  (void)dsatetsime_change_indicator_state( DSAT_CIND_INDEX_CALLSETUP,
                                           DSAT_CIND_CSETUP_MTRING, subs_id );

  if ( call_event->event_info.call_type == CM_CALL_TYPE_VOICE ||
       call_event->event_info.call_type == CM_CALL_TYPE_VT ||
       call_event->event_info.call_type == CM_CALL_TYPE_EMERGENCY )
  {
    call_da_val->etsicall_wait_call_present = TRUE;
    call_da_val->etsicall_wait_call_id = call_event->event_info.call_id;

    /* Generate debug message call list */
    etsicall_show_call_lists(subs_id);
    /* Only RING the TE when there are no active or held calls  */
    if ( (call_da_val->etsicall_num_active_calls == 0 ) && ( call_da_val->etsicall_num_held_calls == 0 ))
    {
      /* Report CLIP for IP Call during Incoming call event */
      /* For CS call clip info is prepared during call setup indicaiton only.
         Here we are preparing CLIP information for IP Call and sent after RING Indication */
      if(call_event->event_info.dsat_mode_info.info_type == CM_CALL_MODE_INFO_IP)
      {
        dsatetsicmif_get_clip_info_or_report_result(subs_id, call_event);
      }
      result = dsatvoice_call_event_incom(subs_id,
                                          &call_event->event_info);
    }
    /* Else display the incoming call as a URC +CCWA: */
    else 
    {
      /* Update dsatvoice state machine state */
      voice_state[subs_id][call_da_val->etsicall_wait_call_id].state = DSAT_VOICE_STATE_WAITING;
      voice_state[subs_id][call_da_val->etsicall_wait_call_id].cmd_active = VOICE_CMD_NONE;
      voice_state[subs_id][call_da_val->etsicall_wait_call_id].call_mode =  call_event->event_info.dsat_mode_info.info_type;

      call_event->event_info.report_ccwa = TRUE;
    }
  }

  return result;
} /* dsatetsicall_call_event_incom */

#ifdef FEATURE_DUAL_ACTIVE
/*===========================================================================

FUNCTION DSATETSICALL_CALL_EVENT_LOCAL_HOLD

DESCRIPTION
  This function is called by dsatcmif_cm_call_event_handler when CM
  reports the CM_CALL_EVENT_LOCAL_HOLD event and moves the calls
  between active call list and local held call list.

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None
  
===========================================================================*/
void dsatetsicall_call_event_local_hold
(
  ds_at_cm_call_event_type* call_event,    /* DS Command pointer */
  sys_modem_as_id_e_type    subs_id        /* Subsription ID */
)
{
  dsatetsicall_call_state_da_info  *call_da_val = NULL;
  
  call_da_val = dsat_get_base_addr_per_subs(DSAT_CALL_DA_VALS, subs_id, TRUE);
  if (NULL == call_da_val)
  {
    return;
  }

  /* Generate debug message call list */
  etsicall_show_call_lists(subs_id);

  switch (call_event->event_info.local_hold_state)
  {
    case CM_CALL_HOLD_STATE_ACTIVE:
      /* Move local held calls to active call list, excluding none */
      (void)etsicall_move_calls( &call_da_val->etsicall_num_local_held_calls,
                                  call_da_val->etsicall_local_held_call_ids,
                                 &call_da_val->etsicall_num_active_calls,
                                  call_da_val->etsicall_active_call_ids,
                                 CM_CALL_ID_INVALID );
      break;

    case CM_CALL_HOLD_STATE_LOCAL_HOLD:
      /* Move active calls to local held call list, excluding none */
      (void)etsicall_move_calls( &call_da_val->etsicall_num_active_calls,
                                  call_da_val->etsicall_active_call_ids,
                                 &call_da_val->etsicall_num_local_held_calls,
                                  call_da_val->etsicall_local_held_call_ids,
                                 CM_CALL_ID_INVALID );
      break;

    default:
      break;
  }

  /* Generate debug message call list */
  etsicall_show_call_lists(subs_id);

  return;
} /* dsatetsicall_call_event_local_hold */
#endif /* FEATURE_DUAL_ACTIVE */
#ifdef FEATURE_WCDMA


/*===========================================================================

FUNCTION DSATETSICALL_ES_EXPORT

DESCRIPTION
  This function export the +ES's value to other subsystem.

DEPENDENCIES
  None
  
RETURN VALUE
  None

SIDE EFFECTS
  None
  
===========================================================================*/
void dsatetsicall_es_export
(
  void
)
{
  int index;
  dsat_string_item_type * str_item;
  
  /* export the 1st and 3rd arguemnt of +ES
     the 2nd argument of +ES is not supported, dsat_es_export_val[1] is 0,
     leave it alone */
  for (index = 0; index < 3; index++)
  {
    if(index == 1)
    {
      continue;
    }
    str_item = (uint8 *)dsatutil_get_val(DSATETSI_EXT_ES_IDX,0,index,MIX_STR_TYPE);
    if(str_item[0] == '\0')
    {
      dsat_set_es_export_val(index, 0);
    }
    else
    {
      if (ATOI_OK != dsatutil_atoi(&dsat_es_export_val[index], 
                                    str_item,
                                    10))
      {
       DS_ATCOP_ERROR_LOG_0("Error in ES parameter export");
      }
    }
  }

} /* dsatetsicall_es_export */


/*===========================================================================

FUNCTION DSATETSICALL_ESA_EXPORT

DESCRIPTION
  This function export the +ESA's value to other subsystem.

DEPENDENCIES
  None
  
RETURN VALUE
  None

SIDE EFFECTS
  None
  
===========================================================================*/
void dsatetsicall_esa_export
(
  void
)
{
  int index;
  dsat_num_item_type tmp_dsat_esa_export_val;

  /* export the 1 (trans_idle),5(crc_type),6(nrzi_en),
     7th(syn1) of +ESA argument.
     the index 2(trans_idle),3(framed_un_ov),4(hd_auto),
     8th(sync2) argument of +ESA are not supported,
     leave them alone */

  for (index = 0; index < 8; index++)
  {
    if((index == 1) || (index == 2) || (index == 3) || (index == 7))
    {
      continue;
    }

    tmp_dsat_esa_export_val = (dsat_num_item_type)dsatutil_get_val(
                                   DSATETSI_EXT_ESA_IDX,0,index,MIX_NUM_TYPE);
    dsat_set_esa_export_val(index, tmp_dsat_esa_export_val);
  }
} /* dsatetsicall_esa_export */

#endif /* FEATURE_WCDMA */


/*===========================================================================

FUNCTION  DSATETSICALL_CAOC_TIMER_EXPIRED_HANDLER 

DESCRIPTION
  This function is the handler function for the +CAOC command
  reporting timer expired event.

DEPENDENCIES
  None

RETURN VALUE
  DSAT_ASYNC_EVENT

SIDE EFFECTS
  None

===========================================================================*/
/* ARGSUSED */
dsat_result_enum_type dsatetsicall_caoc_timer_expired_handler
(
  ds_cmd_type         * cmd_ptr              /* DS Command pointer         */
)
{  
  dsat_timer_s_type *t_ptr = &dsatutil_timer_table[DSAT_TIMER_CAOC_REPORT];
  
  /* Generate +CAOC unsolicated response */
  if (DSAT_DL_VALIDATE_SYMBOL_ADDR(dsatdl_vtable.etsicall_report_aoc_ccm_fp))
  {
    dsatdl_vtable.etsicall_report_aoc_ccm_fp(NULL);
  }
  else
  {
    dsatetsicall_call_state_ms_info *call_ms_val = NULL;

    call_ms_val = dsat_get_base_addr_per_subs(DSAT_CALL_MS_VALS, dsat_get_current_subs_id(TRUE), TRUE);
    if (NULL != call_ms_val)
    {
      /* Query Call Manager for current call meter */
      /* Returned value is in units of 1000's (per UI code) */
      call_ms_val->etsicall_prev_ccm_val = cm_ph_cmd_aoc_get_ccm() / 1000;
    }
  }

  /* Reset timer for next reporting interval */
  (void) rex_set_timer( t_ptr->timer_ptr, t_ptr->duration );
  t_ptr->is_running = TRUE;
  
  return DSAT_ASYNC_EVENT;
} /* dsatetsicall_caoc_timer_expired_handler */

#if defined(FEATURE_DATA_GCSD) || defined(FEATURE_DATA_WCDMA_CS)


/*===========================================================================

FUNCTION  DSATETSICALL_INIT_RLP_EXPORT

DESCRIPTION
  This function intializes the CS Data RLP control variables.

DEPENDENCIES
  None
  
RETURN VALUE
  None
  
SIDE EFFECTS
  None
===========================================================================*/
void dsatetsicall_init_rlp_export ( void )
{
  uint8 i, vindex;
  dsat_num_item_type index;
  /* Initialize +CRLP multidimensional value list */
  for (i=0; i < MAX_CRLP_VERSIONS; i++)
  {
    vindex = rlpv_xref[ i ];
    CRLP_SIZE(i ,CRLP_IWS,index)
    DSATUTIL_SET_VAL(DSATETSI_EXT_CRLP_IDX,0,index,0,
                          dsat_crlp_dflm[vindex][CRLP_IWS].default_v,NUM_TYPE)


    CRLP_SIZE(i ,CRLP_MWS,index)
    DSATUTIL_SET_VAL(DSATETSI_EXT_CRLP_IDX,0,index,0,
                            dsat_crlp_dflm[vindex][CRLP_MWS].default_v,NUM_TYPE)


    CRLP_SIZE(i ,CRLP_T1,index)
    DSATUTIL_SET_VAL(DSATETSI_EXT_CRLP_IDX,0,index,0,
                             dsat_crlp_dflm[vindex][CRLP_T1].default_v,NUM_TYPE)


    CRLP_SIZE(i ,CRLP_N2,index)
    DSATUTIL_SET_VAL(DSATETSI_EXT_CRLP_IDX,0,index,0,
                             dsat_crlp_dflm[vindex][CRLP_N2].default_v,NUM_TYPE)

  }

  /* Initialize +CV120 multidimensional value list */
  dsat_set_cv120_export_val((dsat_num_item_type)DSAT_CV120_DEFAULT_VALUE);
    
  return;
} /* dsatetsicall_init_rlp_export */


/*===========================================================================

FUNCTION DSATETSICALL_UPDATE_CRLP_PARAM_SET

DESCRIPTION
  This function performs parameter set validation for +CRLP.  If
  validation successful, the dsat_crlp_val array is updated for the
  specified RLP version.

DEPENDENCIES
  None

RETURN VALUE
  returns an enum that describes the result of validation.
  possible values:
    DSAT_ERROR : if there was any problem
    DSAT_OK : if it is a success.

SIDE EFFECTS
  None
  
===========================================================================*/
dsat_result_enum_type dsatetsicall_update_crlp_param_set
(
  const ds_ucsd_rlp_type  *rlp_params_ptr    /* +CRLP parameter values */
)
{
  uint8 set;
  dsat_num_item_type index;
#define VALIDATE_CRLP_PARAM(set, index, val) \
  if ( (dsat_crlp_dflm[set][index].lower > val ) || \
       (dsat_crlp_dflm[set][index].upper < val ) ) \
  { \
    DS_AT_MSG3_ERROR("+CRLP[%d] value outside range [%d, %d]", \
	       index, \
	       dsat_crlp_dflm[set][index].lower, \
	       dsat_crlp_dflm[set][index].upper ); \
    return DSAT_ERROR; \
  }

  DSATETSICALL_EX_ASSERT( NULL != rlp_params_ptr );

  /* Validate RLP version to select limit set */
  if (MAX_CRLP_VERSIONS <= rlp_params_ptr->version)
  {
    /* Value outside limits */
    DS_AT_MSG3_HIGH("Value outside range: %d [%d, %d]",
	      rlp_params_ptr->version, 0, MAX_CRLP_VERSIONS);
    return DSAT_ERROR;
  }
  else
  {
    /* RLP v{0,1} use initial set, v2 uses second set */
    set = rlpv_xref[rlp_params_ptr->version];
  }
      
  DS_AT_MSG1_MED("Update +CRLP param set: ver=%d",rlp_params_ptr->version);
  
  /* Validate each parameter in RLP version set */
  VALIDATE_CRLP_PARAM( set, CRLP_IWS, rlp_params_ptr->iws );
  VALIDATE_CRLP_PARAM( set, CRLP_MWS, rlp_params_ptr->mws );
  VALIDATE_CRLP_PARAM( set, CRLP_T1,  rlp_params_ptr->T1 );
  VALIDATE_CRLP_PARAM( set, CRLP_N2,  rlp_params_ptr->N2 );

  /* Reaching here means parameter set is valid, update +CRLP settings. */
  CRLP_SIZE(rlp_params_ptr->version ,CRLP_IWS,index)
  DSATUTIL_SET_VAL(DSATETSI_EXT_CRLP_IDX,0,index,0,rlp_params_ptr->iws,NUM_TYPE)

  CRLP_SIZE(rlp_params_ptr->version ,CRLP_MWS,index)
  DSATUTIL_SET_VAL(DSATETSI_EXT_CRLP_IDX,0,index,0,rlp_params_ptr->mws,NUM_TYPE)

  CRLP_SIZE(rlp_params_ptr->version ,CRLP_T1,index)
  DSATUTIL_SET_VAL(DSATETSI_EXT_CRLP_IDX,0,index,0,rlp_params_ptr->T1,NUM_TYPE)

  CRLP_SIZE(rlp_params_ptr->version ,CRLP_N2,index)
  DSATUTIL_SET_VAL(DSATETSI_EXT_CRLP_IDX,0,index,0,rlp_params_ptr->N2,NUM_TYPE)
  
  return DSAT_OK;
} /* dsatetsicall_update_crlp_param_set */


/*===========================================================================

FUNCTION DSATETSICALL_UPDATE_DS_PARAM_SET

DESCRIPTION
  This function performs parameter set validation for +DS.  If
  validation successful, the dsat_ds_val array is updated.

DEPENDENCIES
  None

RETURN VALUE
  returns an enum that describes the result of validation.
  possible values:
    DSAT_ERROR : if there was any problem
    DSAT_OK : if it is a success.

SIDE EFFECTS
  None
  
===========================================================================*/
dsat_result_enum_type dsatetsicall_update_ds_param_set
(
  const ds_ucsd_v42bis_type  *ds_params_ptr    /* +DS parameter values */
)
{
#define VALIDATE_DS_PARAM(index, val) \
  if ( (dsat_ds_dflm[index].lower > val ) || \
       (dsat_ds_dflm[index].upper < val ) ) \
  { \
    DS_AT_MSG3_ERROR("+DS[%d] value outside range [%d, %d]", \
	       index, \
	       dsat_ds_dflm[index].lower, \
	       dsat_ds_dflm[index].upper ); \
    return DSAT_ERROR; \
  }

  DSATETSICALL_EX_ASSERT( NULL != ds_params_ptr );
  
  DS_AT_MSG1_MED("Update +DS param set: dir=%d",ds_params_ptr->direction);
  
  /* Validate each parameter in DS version set */
  VALIDATE_DS_PARAM( 0, ds_params_ptr->direction );
  VALIDATE_DS_PARAM( 1, ds_params_ptr->negotiation );
  VALIDATE_DS_PARAM( 2, ds_params_ptr->max_dict );
  VALIDATE_DS_PARAM( 3, ds_params_ptr->max_string );

  /* Reaching here means parameter set is valid, update +DS settings. */
  
  DSATUTIL_SET_VAL(DSAT_EXT_DS_IDX,0,0,0,ds_params_ptr->direction,NUM_TYPE)
  DSATUTIL_SET_VAL(DSAT_EXT_DS_IDX,0,1,0,ds_params_ptr->negotiation,NUM_TYPE)
  DSATUTIL_SET_VAL(DSAT_EXT_DS_IDX,0,2,0,ds_params_ptr->max_dict,NUM_TYPE)
  DSATUTIL_SET_VAL(DSAT_EXT_DS_IDX,0,3,0,ds_params_ptr->max_string,NUM_TYPE)
  return DSAT_OK;
} /* dsatetsicall_update_ds_param_set() */

#endif /* defined(FEATURE_DATA_GCSD) || defined(FEATURE_DATA_WCDMA_CS) */


/*===========================================================================

FUNCTION ETSICALL_MOVE_CALLS

DESCRIPTION
  This function moves calls from one call list to another, excluding call
  excl_call_id if it is something other than CM_CALL_ID_INVALID. It is used by
  event handlers that maintain call state info.

DEPENDENCIES
  None

RETURN VALUE
  returns an enum that describes the result of validation.
  possible values:
    TRUE:   if call id to be excluded was found
    FALSE : if not found

SIDE EFFECTS
  None
  
===========================================================================*/
LOCAL boolean etsicall_move_calls
(
  uint8 *fm_qty,
  cm_call_id_type *fm_list,
  uint8 *to_qty,
  cm_call_id_type *to_list,
  const cm_call_id_type excl_call_id
)
{
  uint8 fm_idx,to_idx;
  boolean excl_found = FALSE;

  for ( fm_idx = 0, to_idx = *to_qty;
        fm_idx < *fm_qty && fm_idx < CM_CALL_ID_MAX && to_idx < CM_CALL_ID_MAX;
        fm_idx++, to_idx++ )
  {
    if ( excl_call_id != CM_CALL_ID_INVALID &&
         fm_list[fm_idx] == excl_call_id )
    {
      excl_found = TRUE;
    }
    else
    {
      to_list[to_idx] = fm_list[fm_idx];
    }
  }

  if ( excl_found )
  {
    *to_qty += (*fm_qty - 1);
    *fm_qty = 1;
    fm_list[0] = excl_call_id;
  }
  else
  {
    *to_qty += *fm_qty;
    *fm_qty = 0;
  }

  return excl_found;
} /* etsicall_move_calls */



/*===========================================================================

FUNCTION ETSICALL_SEARCH_CALL_LIST

DESCRIPTION
  This function searches for the call id in the call list provided, 
  deleting it if remove is TRUE and returning TRUE if call id was found. 
  It is used by event handlers that maintain call state info.

DEPENDENCIES
  None

RETURN VALUE
  returns an enum that describes the result of validation.
  possible values:
    TRUE :  if call id was found
    FALSE : not found.

SIDE EFFECTS
  Call id is removed from list per boolean remove 
  
===========================================================================*/
boolean etsicall_search_call_list
(
  uint8 *call_qty,
  cm_call_id_type *call_list,
  const cm_call_id_type call_id,
  boolean rmv_call_id
)
{
  uint8 idx;
  boolean found = FALSE;

  /* Search call list for call id... */
  for ( idx = 0; 
        idx < *call_qty && idx < CM_CALL_ID_MAX; 
        idx++ )
  {
    /* If found... */
    if ( call_list[idx] == call_id )
    {
      found = TRUE;

      if ( rmv_call_id )
      {
        for ( ; 
              idx < (*call_qty - 1) && idx < (CM_CALL_ID_MAX - 1); 
              idx++ )
        {
          call_list[idx] = call_list[idx + 1];
        }

        if ( *call_qty != 0 )
        {
          (*call_qty)--;
        }
      }

      break;
    }
  }

  return found;
} /* etsicall_search_call_list */


/*===========================================================================

FUNCTION ETSICALL_SHOW_CALL_LISTS

DESCRIPTION
  This function displays the current call lists as diag messages.

DEPENDENCIES
  None

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
void etsicall_show_call_lists
(
  sys_modem_as_id_e_type subs_id
)
{
  uint8 idx;
  dsatetsicall_call_state_da_info  *call_da_val = NULL;
  
  call_da_val = dsat_get_base_addr_per_subs(DSAT_CALL_DA_VALS, subs_id, TRUE);
  if (NULL == call_da_val)
  {
    return;
  }

  DS_AT_MSG1_MED("etsicall_num_active_calls %d",call_da_val->etsicall_num_active_calls);
  for (idx=0; idx < call_da_val->etsicall_num_active_calls; idx++)
  {
    DS_AT_MSG2_MED("etsicall_active_call_ids[%d] %d",
             idx, call_da_val->etsicall_active_call_ids[idx]);
  }

  DS_AT_MSG1_MED("etsicall_num_held_calls %d",call_da_val->etsicall_num_held_calls);
  for (idx=0; idx < call_da_val->etsicall_num_held_calls; idx++)
  {
    DS_AT_MSG2_MED("etsicall_held_call_ids[%d] %d",
             idx, call_da_val->etsicall_held_call_ids[idx]);
  }

  DS_AT_MSG2_MED("wait_call_present %d, id %d",
           call_da_val->etsicall_wait_call_present,call_da_val->etsicall_wait_call_id);

#ifdef FEATURE_DUAL_ACTIVE
  DS_AT_MSG1_MED("etsicall_num_local_held_calls %d",call_da_val->etsicall_num_local_held_calls);
  for (idx=0; idx < call_da_val->etsicall_num_local_held_calls; idx++)
  {
    DS_AT_MSG2_MED("etsicall_local_held_call_ids[%d] %d",
             idx, call_da_val->etsicall_local_held_call_ids[idx]);
  }
#endif /* FEATURE_DUAL_ACTIVE */
} 

#endif /* FEATURE_DSAT_ETSI_MODE */

